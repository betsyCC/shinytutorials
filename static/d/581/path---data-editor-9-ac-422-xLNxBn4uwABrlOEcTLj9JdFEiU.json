{"data":{"markdownRemark":{"html":"<h2>Contents</h2>\n<ol>\n<li><a href=\"#data-editor-about\">Why would I need this?</a></li>\n<li><a href=\"#data-editor-work\">How does the app work?</a></li>\n<li><a href=\"#data-editor-run\">How can I run the demo?</a></li>\n</ol>\n<span id=\"data-editor-about\"/>\n<h2>Why would I need this?</h2>\n<p>This app was created in order to figure out a question I've had for a\nwhile: \"How can I edit a dataset in a shiny app?\"</p>\n<p>A data editor would be useful as this would\nallow you to keep a master dataset (source of truth) and an archive of all\nversions. This would be help fix typos that occurred during the data entry process\nor allow you to make other necessary changes (e.g., name changes, modifying a value if it was entered incorrectly,\nupdating information, etc.) on the fly rather than writting script to recode a value at column X, row Y. </p>\n<p>In this tutorial, we will learn how to build a basic data editor in a\nshiny using the rhandsontable package. Here's a preview of what we\nwill make.</p>\n<p><img src=\"https://raw.githubusercontent.com/davidruvolo51/shinyAppTutorials/master/Data-Editor/data-editor.gif\" alt=\"a video showing how to edit and save changes in a data table\"></p>\n<span id=\"data-editor-work\" />\n<h2>How does the app work?</h2>\n<p>The app was developed with the help of vignettes in the wonderful\nrhandsontable package, various features in the shinyBS and\nshinyJS packages. In this example, we will using the <code>mtcars</code>\ndataset.</p>\n<p>To make the app work, there's a base file <code>cars data.RDS</code> that we will use as our source of truth.</p>\n<h3>Building the UI</h3>\n<p>First things first - let's setup the ui. We will use a sidebar\nlayout for our app. We also create a set of buttons that will be used\nfor triggering the editor and for saving data. We will define the\nfollowing buttons</p>\n<ul>\n<li>view: button to display the table as is (without editing\nprivileges)</li>\n<li>edit: button to render table as a rhandsontable output</li>\n<li>cancel: button to discard all edits and return back to the\nnormal table</li>\n<li>save: button to save all edits</li>\n<li>refresh: button to refresh the app (pull all changes in to the\ndefault view)</li>\n</ul>\n<p>We will also create two modals. The first modal will be triggered when\nthe save button is clicked and will ask, are you sure you want to\nsave the changes?. If the user clicks yes, then the save function\nwill run. Once the file is saved, a confirmation dialogue will appear\n(all changes were saved) and prompting you to refresh the app to view\nthe changes.</p>\n<p>Here's what our ui looks like.</p>\n<h3>Building the UI</h3>\n<pre><code class=\"language-r\">ui &#x3C;- shinyUI(\n\n    fluidPage(\n        \n        # shinyjs\n        useShinyjs(),\n        extendShinyjs(text = \"shinyjs.refresh = function(){history.go(0);}\"),\n        \n        # title\n        titlePanel(\"Data Editor\"),\n        \n        # set layout\n        sidebarLayout(\n            \n            # sidebarpanel\n            sidebarPanel(\n                \n                # text + buttons\n                helpText(\"What would you like to do?\"),\n                actionButton(\"view\", label = \"view\", icon = icon(\"binoculars\")),\n                actionButton(\"edit\", label = \"edit\", icon = icon(\"pencil\")),\n                actionButton(\"cancel\", label = \"cancel\", icon = icon(\"times\")),\n                actionButton(\"save\", label = \"save\", icon = icon(\"save\")),\n                actionButton(\"refresh\", label = \"refresh\", icon = icon(\"refresh\")),\n                \n                # modal: confirm changes\n                bsModal(id = \"saveChanges\", \n                        title = \"Do you want to save changes?\",\n                        trigger =  \"save\", \n                        size = \"small\",\n                        # text + buttons\n                        wellPanel(\n                            helpText(\"Saving will overwrite existing data! This cannot be undone.\"),\n                            actionButton(inputId = \"no\", label =  \"No\"),\n                            actionButton(inputId = \"yes\", label = \"Yes\")\n                        )\n                ),\n                \n                # modal: notification\n                bsModal(id = \"okay\", \n                        title = \"Save was successful!\", \n                        trigger = \"yes\", \n                        size = \"small\",\n                        \n                        # notification\n                        wellPanel(\n                                helpText(\"Changes were saved successfully. Refresh the page for changes to take effect.\")\n                        )\n                )\n            ),\n                                \n            # main panel\n            mainPanel(\n                                    \n                # orientation text: current mode - view vs edit\n                uiOutput(\"helperText\"),\n                hr(),\n                                    \n                # table outputs\n                dataTableOutput(\"table\"),\n                rHandsontableOutput(\"hot\")\n            )\n        )\n    )\n)\n</code></pre>\n<p>Now let's move over to the server.</p>\n<h3>Building the server</h3>\n<p>Let's set the defaults. In our app, we've created a helperText\nelement that will allow us to pass messages to the UI. This is useful\nfor letting the user know which mode they are currently in (e.g., view\nor edit). We will set a default message to view. We will also set\nthe default dataTableOutput to render our dataset as is. Also by\ndefault, we will hide the cancel, save, and refresh buttons\nas these buttons are only necessary in editing mode. There are also\na few events for showing and hiding buttons. I won't go into detail in\nthis guide. The source code is self explanatory.</p>\n<p>The most important default is preparing an object to process the changes\nfrom the editing mode. We will create a reactiveValue object and call it\nvalues. Here's what our server setup looks like when we put in all\nof the default parameters. We will set up the observeEvents for all of\nthe buttons. Also we will also define the logic for loading in the\ndataset.</p>\n<pre><code class=\"language-r\"># logic for loading data file using mtcars\ntestFile &#x3C;- \"cars_data.rds\"\n\n\n# if our data file exists, otherwise create it!\nif(file.exists(testFile)){\n    mtcarsDF &#x3C;- readRDS(\"cars_data.rds\")\n} else {\n    mtcarsDF &#x3C;- mtcars\n    row.names(mtcarsDF) &#x3C;- NULL\n    mtcarsDF$car &#x3C;- row.names(mtcars)\n    mtcarsDF &#x3C;- mtcarsDF[,c(12, 1:11)]\n}\n\n\n# server \nserver &#x3C;- function(input, output, session){\n\n    # orientation text: mode - view vs edit\n    output$helperText &#x3C;- renderUI({\n        h3(\"View Mode\")\n    })\n                                \n    # datatable: view\n    output$table &#x3C;- DT::renderDataTable({\n        DT::datatable(mtcarsDF, selection = \"none\")\n    })\n                                \n    # initiate values for edits\n    values = reactiveValues()\n\n    # refresh page\n    observeEvent(input$refresh, {\n        js$refresh()\n    })\n\n    # if view or cancel is clicked, go back to default view\n    observeEvent({input$view input$cancel}, {\n        ...\n    })\n\n    # switch to editing mode\n    observeEvent(input$edit, {\n        ...\n    })\n\n    # save changes\n    observeEvent(input$yes,{\n        ...\n    })\n}\n</code></pre>\n<p>The events for view, cancel, and refresh are pretty straightforward.\nThese events show and hide buttons, as well refresh the view. Let's\nfocus on the events for editing and saving</p>\n<h3>Editing Mode</h3>\n<p>When the user clicks the edit button, the displayed table switches to an\nrhandsontable output. The following code allows us to make changes and\ndirectly render the changes in the ui. It also stores the changes into\nour reactive object values.</p>\n<pre><code class=\"language-r\">observeEvent(input$edit, {\n    ...\n\n    # make data.frame of edits\n    data &#x3C;- reactive({\n    \n        if(!is.null(input$hot)){\n            DF &#x3C;- hot_to_r(input$hot)\n        } else {\n            if(is.null(values[[\"DF\"]])){\n                DF &#x3C;- data.frame(mtcarsDF)\n            } else {\n                DF &#x3C;- values[[\"DF\"]]\n            }\n        }\n                            \n        values[[\"DF\"]] = DF\n        DF\n                            \n    })\n                        \n    # render table\n    output$hot &#x3C;- renderRHandsontable({\n        DF = data()\n        if (!is.null(DF))\n            rhandsontable(DF, stretchH = \"all\")\n        })\n})\n</code></pre>\n<h3>Saving Changes</h3>\n<p>In this app, we've defined the save process as:</p>\n<ol>\n<li>Create a backup of the master file we will rename our current\nmaster file to include a timestamp (the time the save event was\ntriggered).</li>\n<li>Create a new master file: Now that we've created a backup of\nour master, we can now create a new master file that includes all of\nthe changes we made. The present method saves the changes to a\n.RDS file. Alternatively, you can write the changes to csv or\nyour preferred place (e.g., googlesheets, mongoDB, etc.).</li>\n</ol>\n<pre><code class=\"language-r\"># When yes is clicked, save data as RDS\nobserveEvent(input$save,{\n                        \n    finalDF &#x3C;- isolate(values[[\"DF\"]])\n\n    # write data + backup current version\n    if(file.exists(\"cars_data.RDS\")){\n                        \n        # rename current master file\n        file.rename(\n            from = \"cars_data.RDS\",\n            to = paste0(\"cars_data_\",format(Sys.time(),\"%Y%m%d-%H%M%S\"),\".RDS\")\n        )\n                        \n        # write edits to file\n        saveRDS(mtcarsDF, file = \"cars_data.RDS\")\n                        \n    } else {\n                    \n        # save data if a master file isn't present\n        saveRDS(mtcarsDF, file = \"cars_data.RDS\")\n\n    }\n\n})\n</code></pre>\n<p>Once the save event runs, the user will receive a notification saying\nthat the file was saved and will inform the user to refresh the page.\nWhen the page is refreshed, the master file will be reloaded and the\nprevious version will be uneffected. Creating backups is a good way to\ntrack changes in the data. The timestamp is formated to:\nyyyymmdd-HHMMSS. Seconds may not be necessary in all cases; adjust as\nrequired.</p>\n<span id=\"data-editor-run\" />\n<h2>How can I run the demo? {#data-editor-run}</h2>\n<p>The source code is available on\n<a href=\"https://github.com/davidruvolo51/shinyAppTutorials/tree/master/Data-Editor\">github</a>.\nAlternatively, you can run the demo in R using the following code.</p>\n<pre><code class=\"language-r\"># Run in R/Rstudio\ninstall.packages(\"shiny\")\nshiny::runGitHub(repo=\"shinyAppTutorials\",username=\"davidruvolo51\",subdir=\"Data-Editor\")\n</code></pre>","frontmatter":{"title":"Data Editor","subtitle":"A shiny app for editing data in a shiny app","abstract":"Have you ever wanted to edit data in a shiny app? Learn how to build a shiny app for editing data and saving changes to file, and then reloading the changes into your app.","date":"2018-03-01","keywords":["rhandsontable"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/data-editor/"}}